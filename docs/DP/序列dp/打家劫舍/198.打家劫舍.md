198.打家劫舍
----------

 - 题目
> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
----------
 - 示例
> 输入：coins = [1, 2, 3, 1]
>
> 输出：4
> 
> 解释：偷1号，再偷3号，得到最高价值
>
----------
- 代码
>
>
    class Solution:
        def rob(self, nums: List[int]) -> int:
            dp = [[0,0]]*(len(nums)+1)
            for i in range(1,len(nums)+1):
                temp = dp[i-1][0]
                dp[i][0] = max(dp[i-1][0],dp[i-1][1])
                dp[i][1] = temp+nums[i-1]
            return max(dp[-1])
>
    class Solution:
        def rob(self, nums: List[int]) -> int:
            n = len(nums)
            dp_i_1 = 0#当前第i间偷
            dp_i_2 = 0#当前第i间不偷
            for i in range(n):
                temp = dp_i_2
                dp_i_2 = max(dp_i_2,dp_i_1)
                dp_i_1 = temp+nums[i]
            return max(dp_i_2,dp_i_1)
> 由于每次计算都刚好基于上一次，所以只需每次更新两个数即可
----------
- 解析
> 如果我们知道了nums[:k]即前k个房子的最优盗窃方案，则可以由其推出nums[:k+1]的最优盗窃方案，**即最优解由其子问题的最优解得到**，
> 所以这是一个一维的动态规划问题；
>
> 上述条件中，nums[:k+1]的最优方案取决于nums[k]是否被偷取，如果被偷取，则不能偷取nums[k+1]，反之，则可以；
>
> 因此要对比两种方案谁才是nums[:k+1]的最优方案，所以每个位置都要记录nums[i]偷/不偷的最优方案；
>
> 所以状态转移公式为：
>
    dp[i]['偷'] = dp[i-1]['不偷']+nums[i] (因为这一间偷了，所以相邻的前一间不能偷)
    dp[i]['不偷'] = max(dp[i-1][‘偷'],dp[i-1][’不偷'])
> dp[i]表示到当前位置为止的最优盗取方案的价值,即nums[:i]对应的最优盗取方案的价值