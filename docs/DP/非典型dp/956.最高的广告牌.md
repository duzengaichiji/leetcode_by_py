956.最高的广告牌
----------
 - 题目
>你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。
>
>你有一堆可以焊接在一起的钢筋 rods。举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。
>
>返回 广告牌的最大可能安装高度 。如果没法安装广告牌，请返回 0 。
>
 - 示例
 ----------
> input: forest = [1,2,3,6]
> 
> 
> output: 6
 ----------
 - 代码
 >
> 
    class Solution:
        def tallestBillboard(self, rods):
            # 初始状态谁都不选，正数和为0
            dp = {0: 0}
            for i in rods:
                for k, b in list(dp.items()):
                    dp[k + i] = max(dp.get(k + i, 0), b + i)
                    dp[k - i] = max(dp.get(k - i, 0), b)
            return dp[0]
  ----------
 - 解析
 >
> 这个问题，应该转换为**求数组和为0的组合**问题；
> 
> 对于列表中的任意一个数，我们取其三种**状态**，1,-1,0，即取该数的正值，负值，不取这个值的；
> 
> 我们要做是，给列表中的所有数字赋合适的**状态**，使得数组的和为0；
> 
> 这里可以理解为，赋予正状态的元素可以合成一根钢筋，赋予负状态的元素可以合成另一根钢筋，它们刚好**长度相等**；
> 
> 我们要求满足题意的可以合成的最长的钢筋，也就是，使满足题意的数组中的正状态的元素和最大；
> 
> 例如，[1,1,2,2,3]这个数组，我们赋予状态[1,0,-1,-1,1]，可以得到最大钢筋长度为4；
> 
  ----------
>
> 基于上述描述，我们定义dp数组；
> 
> 其中dp[i]表示，总和为i时候的最大正数和；
> 
> 初始状态容易定义dp[i] = 0，此时我们还未加入任何钢筋；
> 
> 之后我们遍历所有钢筋，每根钢筋要对之前的结论进行变更，即当前钢筋i，是作为正数加入，还是作为负数加入；
> 
    for k, b in list(dp.items()):
        # 作为正数加入时，更新记录中的正数和
        dp[k + i] = max(dp.get(k + i, 0), b + i)
        dp[k - i] = max(dp.get(k - i, 0), b)
>
> 如此一来，所有可能的组合，即对rods中所有元素赋予1或-1的各种 加权和，都会被记录到dp里面；
> 
> 并且对应的value是该组合的**最大正数和**
> 
> 因此，我们的答案是dp[0]（看上面一半的解释）