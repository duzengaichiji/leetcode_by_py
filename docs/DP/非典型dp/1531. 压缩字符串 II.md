1531. 压缩字符串 II
----------
 - 题目
>
>
    行程长度编码 是一种常用的字符串压缩方法，它将连续的相同字符（重复 2 次或更多次）替换为字符和表示字符计数的数字（行程长度）。例如，用此方法压缩字符串 "aabccc" ，将 "aa" 替换为 "a2" ，"ccc" 替换为` "c3" 。因此压缩后的字符串变为 "a2bc3" 。

    注意，本问题中，压缩时没有在单个字符后附加计数 '1' 。

    给你一个字符串 s 和一个整数 k 。你需要从字符串 s 中删除最多 k 个字符，以使 s 的行程长度编码长度最小。

    请你返回删除最多 k 个字符后，s 行程长度编码的最小长度 。
 - 示例
 ----------
> input: s = "aaabcccd", k = 2
> 
> 
> output: 4
>
 ----------
 - 代码
 >
>
    class Solution:
        def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
            # 求字符数量代表的长度
            calc = lambda x: 1 if x == 1 else (2 if x < 10 else (3 if x < 100 else 4))
    
            n = len(s)
            f = [[10**9] * (k + 1) for _ in range(n + 1)]
            f[0][0] = 0
            
            for i in range(1, n + 1):
                for j in range(min(k, i) + 1):
                    # 砍掉第j个字符
                    if j > 0:
                        f[i][j] = f[i - 1][j - 1]
                    same = diff = 0
                    for i0 in range(i, 0, -1):
                        # 尽量找到更多的和s[i]一样的字符拿去压缩
                        # 这里当然是从后往前找，即可s[t:i]都是s[i]
                        if s[i0 - 1] == s[i - 1]:
                            same += 1
                            f[i][j] = min(f[i][j], f[i0 - 1][j - diff] + calc(same))
                        else:
                            diff += 1
                            # 这里要理解，我们要尽可能把字符压缩成s[i]的样子
                            # 也就是最多能砍掉j个字符，要尽可能多的s[i]连在一起
                            # 所以当不是s[i]的字符数量多于j个的时候，就没必要继续求了
                            if diff > j:
                                break
            return f[n][k]
  ----------
 - 解析
 >
> 很容易想到dp数组的定义：
> 
> dp[i][j]表示，在最多砍掉j个字符时，s[:i]能够压缩成的串的最小长度；
> 
> 那么，自然很容易联想dp[i][j]的状态转移公式；
> 
> 当我们要砍掉第i个字符时，由于第i个字符被砍了，因此最短串的长度是没变的；
> 
    即dp[i][j] = dp[i-1][j-1]
>
> 难点在于，不砍掉第i个字符时，状态是怎么变化的；
> 
> 这里需要考虑的是第i个字符是否能和前面的最短串的尾部**结合并再压缩**；
>
> 假设s[i]为char；
> 
> 基于上述考虑，我们需要考虑拿到尽可能多的char去进行压缩；
> 
> 由于此时最多能砍掉j个字符；
> 
> 因此我们需要计算，在最多砍掉j个字符的条件下，最多构造出多少个连续的char作为新的最小压缩串的尾部；
> 
> 因此就有了
> 
    f[i][j] = min(f[i][j], f[i0 - 1][j - diff] + calc(same))
> 这里f[i0-1][j-diff]表示，我们将s[i0:i]的子串，通过最多砍j个字符，都压缩成了char的连续串，calc函数用于计算连续char串形成的子串的长度（即"aaaa"="a4"=2,"aaa....aaa"="a12"=3)
> 
> 其他细节在注释中已经清楚了