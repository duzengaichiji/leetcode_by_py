730. 统计不同回文子序列
----------
 - 题目
>给定一个字符串 s，返回 s 中不同的非空「回文子序列」个数 。
>
>通过从 s 中删除 0 个或多个字符来获得子序列。
>
>如果一个字符序列与它反转后的字符序列一致，那么它是「回文字符序列」。
>
>如果有某个 i , 满足 ai != bi ，则两个序列 a1, a2, ... 和 b1, b2, ... 不同。
>
>注意：
>
>结果可能很大，你需要对 109 + 7 取模 。
>
 - 示例
 ----------
> input: "abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba"
> 
> 
> output: 104860361
 ----------
 - 代码
 >
> 
    class Solution(object):
      def countPalindromicSubsequences(self, s):
          """
          :type s: str
          :rtype: int
          """
          MOD = 10**9+7
          n = len(s)
          # dp[i][j] 表示 s[i:j]的回文子序列的总数量
          dp = [[0]*n for _ in range(n)]
          # 初始化，单个字母的串都是回文
          for i in range(n):
              dp[i][i] = 1
          for i in range(n-1,-1,-1):
              for j in range(i+1,n):
                  if s[i]==s[j]:
                      # 将中间部分套上 s[i],s[j]，然后加上 "x","xx",(x=s[i])
                      dp[i][j] = dp[i+1][j-1]*2+2
                      # 扣掉重复的情况
                      l,r = i+1,j-1
                      while l<=r and s[i]!=s[l]:
                          l+=1
                      while l<=r and s[i]!=s[r]:
                          r-=1
                      # 找到s[i]出现的最左和最右，由它们包含的中间一段对应的子序列都将是重复的
                      if l==r:
                          dp[i][j]-=1
                      elif l<r:
                          dp[i][j] -= (2+dp[l+1][r-1])
                  else:
                      # 去掉中间的重复部分
                      dp[i][j] = dp[i+1][j]+dp[i][j-1]-dp[i+1][j-1]
                  dp[i][j] = dp[i][j]%MOD
          return dp[0][n-1]
  ----------
 - 解析
 >
> 
> 显然，我们可以认为 s[i:j]包含的不同回文字符串数量和s[i+1:j-1]相关；
> 
> 所以我们自然想到用dp[n][n]数组存放结果，其中，dp[i][j]表示s[i:j]中包含的不同回文字符串的个数;
> 
> 我们先讨论简单的情况，即dp[i][j]表示s[i:j]中包含的回文字符串的个数
> 
> 则状态转移可以分如下情况讨论
> 
> s[i]==s[j]:
> 
    此时只要将 s[i+1:j-1]中包含的回文字符串拿出，假设为 (aba,a,abba...)
    假设s[i] 为 x，此时 s[i:j]比 s[i+1:j-1]多出来的部分为 (xabax,xax,xabbax...)
    即将它们用x 包裹起来，除此之外，还要算上 (x,xx) 这俩；
>
> 因此，有 dp[i][j] = 2*dp[i+1][j-1]*2+2
> 
> s[i]!=s[j]
> 
    此时，需要分别考虑s[i+1:j]以及s[i:j-1]这两个部分；
    此外，这两个部分的公共部分s[i+1:j-1]要被扣除
>
> 因此，dp[i][j] = dp[i][j-1]+dp[i+1][j]-dp[i+1][j-1]
> 
> 这便是求回文字符串个数的方法；
> 
> 本题需要在这个基础上，考虑求**不同回文字符串**；
> 
> 先考虑s[i]!=s[j]，的情况，显然，因为它实际上不会生成**新的回文字符串**，其计算过程，只是将之前的计算过程做累加；
> 
> 而对于s[i]==s[j]的情况，
> 
> 比如 s[i]=x， 当 s[i+1:j-1]中包含了 **由x包裹的回文字符串** 时，会重复计算；
> 
> （例如， s[i+1:j-1]包含的回文串有 xax,那么显然，它还会包含 x和xx，此时我们计算s[i:j]的回文串时，
> 将会考虑 xxaxx,xxx,xxxxx,除此之外，x,xx,xax也被纳入考虑了）；
> 
> 因此可以看到，s[i+1:j-1]由x包含的子回文串以及x还有xx，这几项会是重复的；
> 
> 因此我们在计算时，将它们扣除即可；
> 
    l,r = i+1,j-1
    while l<=r and s[i]!=s[l]:
        l+=1
    while l<=r and s[i]!=s[r]:
        r-=1
    # 找到s[i]出现的最左和最右，由它们包含的中间一段对应的子序列都将是重复的
    if l==r:
        dp[i][j]-=1
    elif l<r:
        dp[i][j] -= (2+dp[l+1][r-1])
>
> 然而如果l==r,意味着s[i+1:j-1]中只有一个 x，此时只要扣除 (x)这个回文串即可；
> 