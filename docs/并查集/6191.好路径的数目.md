6191. 好路径的数目
----------
- 题目
>
    给你一棵 n 个节点的树（连通无向无环的图），节点编号从 0 到 n - 1 且恰好有 n - 1 条边。

    给你一个长度为 n 下标从 0 开始的整数数组 vals ，分别表示每个节点的值。同时给你一个二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边。
    
    一条 好路径 需要满足以下条件：
    
    开始节点和结束节点的值 相同 。
    开始节点和结束节点中间的所有节点值都 小于等于 开始节点的值（也就是说开始节点的值应该是路径上所有节点的最大值）。
    请你返回不同好路径的数目。
    
    注意，一条路径和它反向的路径算作 同一 路径。比方说， 0 -> 1 与 1 -> 0 视为同一条路径。单个节点也视为一条合法路径。

----------
- 示例
> input : vals = [1,3,2,1,3], edges = [[0,1],[0,2],[2,3],[2,4]]
>
> output : 6
>
----------
 - 代码
> 记忆化搜索+状态压缩
> 
    class Solution:
        def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:
            n = len(vals)
            g = [[] for _ in range(n)]
            for x,y in edges:
                g[x].append(y)
                g[y].append(x)
            
            # 并查集。
            fa = list(range(n))
            # size[i] 表示节点值为vals[x]的节点数量
            size = [1]*n
    
            def find(x):
                if fa[x]!=x:
                    fa[x] = find(fa[x])
                return fa[x]
    
            ans = n
            # 从小到达遍历节点，保证小的连通区域的好路径先被计算之后再被合并
            for vx,x in sorted(zip(vals,range(n))):
                # 当前节点所在的联通区域的最大节点值对应的索引
                fx = find(x)
                # 当前节点的邻居，是否可以加入当前联通区域
                for y in g[x]:
                    y = find(y)
                    # 比自己大的联通区域直接不考虑(因为要按小到大的顺序添加)
                    if y==fx or vals[y]>vx:
                        continue
                    # 如果对面的联通区域和当前连通区域的最大值相等，可以形成的好路径数目是相乘的
                    if vals[y]==vx:
                        ans+=size[fx]*size[y]
                        # 更新节点值的数量数组
                        size[fx]+=size[y]
                    # 将小的节点值合并到节点值更大的连通区域中
                    fa[y] = fx
            return ans
----------
 - 解析
> 
> 先提供一种错误思路；
> 
> 假设当前图中最大的点值为x，有m个，那么这些节点可以形成的好路径数量应为 m(m-1)//2；
> 
> 然后求完值为x（我们将路径起始点和终结点的值定位路径的值）路径之后，将这m个点剔除，并同时剔除对应边，**然后剔除孤立的点**，因为它们不会变成路径了；
> 
> 按照这个流程，理论上可以求得答案；
> 
> 但是剔除孤立点的过程，要重复访问图，会导致复杂度到达O(n²)，然后超时；
>   
----------
> 
> 正确的思路是反过来，将值小的节点并入大的节点中，这样可以保证，轮到大的节点时，它一定是当前联通区域中最大的节点；
> 
> 并且被并入的小的节点对应的联通区域，它们的好路径数量已经被求出来了；
> 