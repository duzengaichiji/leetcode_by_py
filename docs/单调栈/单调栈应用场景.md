> 单调栈是一种很容易理解的数据结构。用一句话来解释，就是栈内的元素，满足一定的单调性；
>
> 单调栈也有出栈和入栈操作；
>
> 为了保持单调性，只有在能够保证栈内元素单调性的时候才会进行push，当破坏了单调性时会触发pop；
>
>
    stack = []
    for num in nums:
        if not stack or num>stack[-1]: # 维持单调性
            stack.append(num)
        else:
            # 触发出栈条件
            while stack and stack[-1]<=num:
                stack.pop()
            stack.append(num) 
> 这样的设计可以帮助我们求得**局部极值**；
>
> 以数组 nums = [1,2,3,4,3,2,1] 为例，我们维护一个单调递增栈；
>
> 显然会在第二个3 触发出栈；
>
> 如果将nums连成线，会发现，在第二个3 处，构成一个“凹”形，即局部极小值；反之，构成凸形则是局部极大值；
>
----------
> 除了pop触发时所表达的局部极值性质，还有一点是被pop出来的元素所表现出的性质；
>
> 仍然以上面那个数组为例，当遍历到第二个3 时，触发4 出栈，此时对于4 来说，**当前遍历元素（3）是出栈元素（4）的右边第一个比自己小（破坏了单调递增性）的元素**；
>
> 许多问题正是利用这个性质去求最优解的；
>
> 例如 84.柱状图中的最大矩形，我们知道，nums中每个高度的能形成的最大矩形都可能是最后答案，当触发了出栈条件时，
> 就可以求得以当前pop出来的num为高度，能形成的最大的矩形面积；
>
> 又例如 907.子数组的最小值之和， 每次触发了pop时，都能得到某个元素右边第一个比它大的元素，再找到左边第一个比它大的元素，就能得到以该元素为最小值
> 的子数组的最大范围； 