526.优美的排列
----------
 - 题目
>假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 <= i <= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：
 
 > 第 i 位的数字能被 i 整除
>
 > i 能被第 i 位上的数字整除
>
 > 现在给定一个整数 N，请问可以构造多少个优美的排列？
>
>其中N<=15
 ----------
 > input: 2
 >
 > output: 2
 ----------
 - 代码
 >
>
> 回溯法
>
>
    class Solution:
        def countArrangement(self, n: int) -> int:
            res = 0
            slot = [-1]*n
            slot.insert(0,0)
            used = [False]*(n+1)
    
            def backtrack(index,used):
                nonlocal res
                if index==n+1:
                    res+=1
                    return
                for i in range(1,n+1):
                    # 数字i是否被填入插槽
                    if not used[i]:
                        # 数字i是否满足填入插槽index的条件
                        if ((index%i)==0 or (i%index)==0):
                            used[i] = True
                            slot[index] = i
                            backtrack(index+1,used)
                            used[i] = False
                            slot[index] = -1
                return
            backtrack(1,used)
            return res
>
>
> 动态规划
>
    class Solution:
        def countArrangement(self, n: int) -> int:
            # 状态总数量
            mask = 1<<n;
            dp = [[0]*mask for _ in range(n+1)]
            dp[0][0] = 1
            # 当前有n个插槽
            for i in range(1,n+1):
                # 选取i个数去构成state的状态
                for state in range(mask):
                    # 选取[1-n]中的任意一个数字
                    for k in range(1,n+1):
                        # k未被选取的状态，跳过
                        if state>>(k-1)&1==0: continue
                        # k不满足插槽i的条件，跳过
                        if k%i!=0 and i%k!=0: continue
                        dp[i][state] += dp[i - 1][state & (~(1 << (k - 1)))]
            return dp[n][mask-1]
>
 ----------
 - 解析
 > 该问题相当于，将[1-N]这N个数字填到N个slot里面，其中每个插槽index上的数字要满足条件：
>
> slot[index]%index==0 or index%slot[index]==0
>
> 显然，暴力求解的话，采用回溯法，尝试将每个数字填入每个插槽；
>
> 如果当前数字可以填入当前插槽，则继续尝试，否则就回溯；
------------
> 鉴于备选数字的最多只有15个（15<32，32的原因大概是int的最大范围)，考虑将可以组成的所有状态用二进制表示出来；
>
> 假设用一个二进制数表示n个数字的被选择情况，例如[00101],表示选择了1和3；
>
> 则将这些被选情况对应的二进制表示转换为整型数，有n位数字最多有 2^n种情形，即2^n种状态；
>
> 而dp数组 dp[n][mask] 的另一维度，则表示当前的可以选取的数字的范围；
>
> 因此，dp[i][state] 则表示 **当前能从[1--n]中选取i个数字放入这i个插槽，且选择的状态为state时，能构成的优美排列的最大数量**
>
> 以n=3为例，此时得到的dp矩阵为
>
>[[1, 0, 0, 0, 0, 0, 0, 0], 
>
>[0, 1, 1, 0, 1, 0, 0, 0], 
>
>[0, 0, 0, 2, 0, 1, 1, 0], 
>
>[0, 0, 0, 0, 0, 0, 0, 3]]
>
> 可以看出，插槽个数为1时，可以放入数字1或2或3，对应状态为[001],[010],[100],恰好对应横坐标的 1,2,4；
>
> 因此，矩阵中的第1行（从0开始）对应的状态位置为1；
>
> 同理，矩阵中的第2行，对应状态为[011],[101],[110]，分别表示选取[1,2]放入插槽，[1,3],[2,3]；
>
> 这三种选取方式，放入2个插槽至多可以构成的优美排列数量为 2，1，1，对应数组上的数字；
>
> 例如，i = 5, state = [0010101] 即表示，选择(5,3,1)三个数字来构成优美排列；
>
> 那么，要求取的就是state = [1111..]时的最大优美排列数，即dp[n][mask]；
>
------------
> 那么，状态与其前置状态是如何转移的；
>
> dp[i][state]取决于dp[i-1]，即i个插槽的情况由i-1个插槽的情况演变而来；
>
> 此时需要枚举多出来的那个插槽填充的数字的情况，即从[1--n]中选取数字k填入最后一个插槽；
>
> 而对于这个k，需要校验它是否可以填入第i个插槽；
>
> 如果当前要求的是dp[i][state]，则k必须满足：
>
> 1. k%i==0 or i%k==0 (题给条件)
>
> 2. state>>(k-1)&1!=0 (state状态里k是被选中的)
>
> 而第i个插槽选取k的前置状态为 state & (~(1 << (k - 1)))，因此可以得到状态转移方程；
>
> dp[i][state] = sum(dp[i-1][state & (~(1 << (k - 1)))],i in [1,n])
>
