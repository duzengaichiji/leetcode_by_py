5269. 从栈中取出 K 个硬币的最大面值和
----------
 - 题目
>
>
    给你一个下标从 0 开始的字符串 s 。另给你一个下标从 0 开始、长度为 k 的字符串 queryCharacters ，一个下标从 0 开始、长度也是 k 的整数 下标 数组 queryIndices ，这两个都用来描述 k 个查询。
    
    第 i 个查询会将 s 中位于下标 queryIndices[i] 的字符更新为 queryCharacters[i] 。
    
    返回一个长度为 k 的数组 lengths ，其中 lengths[i] 是在执行第 i 个查询 之后 s 中仅由 单个字符重复 组成的 最长子字符串 的 长度 。
 - 示例
 ----------
> input: s = "babacc", queryCharacters = "bcb", queryIndices = [1,3,3]
> 
> 
> output: [3,3,4]
> 
    - 第 1 次查询更新后 s = "bbbacc" 。由单个字符重复组成的最长子字符串是 "bbb" ，长度为 3 。
    - 第 2 次查询更新后 s = "bbbccc" 。由单个字符重复组成的最长子字符串是 "bbb" 或 "ccc"，长度为 3 。
    - 第 3 次查询更新后 s = "bbbbcc" 。由单个字符重复组成的最长子字符串是 "bbbb" ，长度为 4 。
    因此，返回 [3,3,4]
 ----------
 - 代码
 >
> 线段树
> 
    class Node:
        def __init__(self):
            self.left,self.right = None,None
            # index
            self.l,self.r = 0,0
            # 最左边/右边的字符
            self.lch,self.rch = None,None
            # 前缀最长连续字符个数，后缀最长连续字符个数
            self.pre,self.suf = 0,0
            # 本区间的最长连续字符个数
            self.most = 0
        def merge(self):
            if not self.left:
                # 叶节点不需要merge
                return
            # 更新pre
            if self.left.lch == self.right.lch and self.left.pre == self.left.r - self.left.l+1:
                # 仅当left是一个重复字符串时，进行合并，计算该节点的pre值
                self.lch = self.left.lch
                self.pre = self.left.pre+self.right.pre
            else:
                # 如果不能合并，则该节点的pre就等于left的pre
                self.lch = self.left.lch
                self.pre = self.left.pre
            # 同理，更新suf
            if self.left.rch == self.right.rch and self.right.suf==self.right.r - self.right.l +1:
                self.rch = self.right.rch
                self.suf = self.right.suf+self.left.suf
            else:
                self.rch = self.right.rch
                self.suf = self.right.suf
            # 更新most，要看中间段是否能连在一起
            self.most = max(self.left.most, self.right.most)
            if self.left.rch == self.right.lch:
                self.most = max(self.most, self.left.suf+self.right.pre)
        @classmethod
        def build(cls, s, l, r):
            cur = cls()
            cur.l,cur.r = l,r
            if l==r:
                # 叶节点
                cur.lch,cur.rch = s[l],s[r]
                cur.pre = cur.suf = 1
                cur.most = 1
            else:
                # 非叶节点
                mid = (l+r)//2
                cur.left = cls.build(s,l,mid)
                cur.right = cls.build(s,mid+1,r)
                cur.merge()
            return cur
        def update(self,idx,ch):
            # 自下而上更新节点
            if self.l==self.r:
                self.lch = self.rch = ch
                return
            if idx<=self.left.r:
                self.left.update(idx,ch)
            else:
                self.right.update(idx,ch)
            self.merge()
    
    class Solution:
        def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:
            segTree = Node.build(s,0,len(s)-1)
            ans = []
            for ch,idx in zip(queryCharacters,queryIndices):
                segTree.update(idx,ch)
                ans.append(segTree.most)
            return ans
  ----------
 - 解析
 >
> 
