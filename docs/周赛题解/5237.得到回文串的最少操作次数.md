5237.得到回文串的最少操作次数
----------
 - 题目
> 
> 给你一个只包含小写英文字母的字符串 s 。
>
>每一次 操作 ，你可以选择 s 中两个 相邻 的字符，并将它们交换。
>
>请你返回将 s 变成回文串的 最少操作次数 。
>
> 注意 ，输入数据会确保 s 一定能变成一个回文串。
>
 - 示例
 ----------
> input: "letelt"
>
> output: 2
 ----------
 - 代码
> 
> 模拟+贪心
> 
    class Solution:
        def minMovesToMakePalindrome(self, s: str) -> int:
            s = list(s)
            n = len(s)
            ans = 0
            i = 0
            # 逐个寻找与左边一半相匹配的字符
            while i<n//2:
                left = i
                # 这个right的定义，是因为right右边的字符都已经是正确的字符
                right = n-left-1
                # 找到与left相匹配的字符
                while s[right]!=s[left]:
                    right-=1
                if left==right:
                    # 如果没找到与left匹配的字符，将它向前推一位；
                    # 最终它们会到中间的位置
                    s[left],s[left+1] = s[left+1],s[left]
                    ans+=1
                    i-=1
                else:
                    # 如果不是这个字符本身，将该对应的right移动到与left对应的位置
                    for j in range(right,n-left-1):
                        s[j],s[j+1] = s[j+1],s[j]
                        ans+=1
                i+=1
            return ans

 ----------
 - 解析
 > 
> 首先，用模拟的思想看这题，要形成回文串，需要字符串的左右两侧中心对称；
> 
> 因此需要将字符移动到它们自己的**最终位置**上；
> 
> 因此逐个遍历字符串左半边的字符，找它们的对应字符，移动到最终位置即可；
> 
> 需要考虑的情况是有奇数个数的字符，它们一定位于回文串的中间；
> 
> 因此当我们发现了某个字符的对应字符就是自己（left=right)，表明它没有匹配的字符，它最终将被移到回文串中间的位置；
> 
> 对于该字符，我们选择往前移动一格，**跳过对它的处理**；
> 
> 待其他字符都回到自己的位置时，该字符必然位于中心位置；
> 
> 其他细节都写在注释中了；