689.三个无重叠子数组的最大和
----------
 - 题目
>给你一个整数数组 nums 和一个整数 k ，找出三个长度为 k 、互不重叠、且 3 * k 项的和最大的子数组，并返回这三个子数组。
> 
> 以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置（下标从 0 开始）。如果有多个结果，返回字典序最小的一个。
>
 - 示例
 ----------
>input: nums = [1,2,1,2,6,7,5,1], k = 2
> 
> output: [0,3,5]
 ----------
 - 代码
 >
> 
> 错误解
> 
    class Solution:
        def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:
            if k>1:
                sumK = []
                for i in range(len(nums)-k+1):
                    sumK.append([i,sum(nums[i:i+k])])
            else:
                sumK = [[i,num] for i,num in enumerate(nums)]
            sumK = sorted(sumK,key=lambda x:(x[1],-x[0]))[::-1]
            res = []
            curMax = -float('inf')
            start = 0
            while start<len(sumK)-2:
                index = start
                tempSum = 0
                temp = []
                while len(temp)<3 and index<len(sumK):
                    if not temp or sum([abs(sumK[index][0]-j)>=k for j in temp])==len(temp):
                        
                        temp.append(sumK[index][0])
                        tempSum+=sumK[index][1]
                    index+=1
                if tempSum>curMax:
                    curMax = tempSum
                    res = temp.copy()
                start+=1
            return sorted(res)
>
> 正解1：三指针
> 
    class Solution:
        def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:
            ans = []
            # 第一个子数组和，第一个子数组的最大和，前者的起始位置
            sum1,maxSum1,maxSum1Idx = 0,0,0
            # 第二个子数组和，前两个子数组的最大和，两者的起始位置
            sum2,maxSum12,maxSum12Idx = 0,0,()
            # 第三个子数组和，三者的最大和
            sum3,maxTotal = 0,0
            # 
            for i in range(k*2,len(nums)):
                # 在i到达3k-1之前，其实算的是第一份子数组和
                # sum1=sum(nums[:k]), sum2=sum(nums[k:2*k])..
                sum1+=nums[i-k*2]
                sum2+=nums[i-k]
                sum3+=nums[i]
                # 更新过程
                if i>=3*k-1:
                    if sum1>maxSum1:
                        maxSum1 = sum1
                        # 记录第一个子数组的起始位置
                        maxSum1Idx = i-3*k+1
                    if maxSum1+sum2>maxSum12:
                        maxSum12 = maxSum1+sum2
                        maxSum12Idx = (maxSum1Idx,i-k*2+1)
                    if maxSum12+sum3>maxTotal:
                        maxTotal = maxSum12+sum3
                        ans = [*maxSum12Idx,i-k+1]
                    # 三个子数组向前移动
                    sum1 -= nums[i - k * 3 + 1]
                    sum2 -= nums[i - k * 2 + 1]
                    sum3 -= nums[i - k + 1]
            return ans
>
> 正解2：动态规划
> 
    class Solution:
        def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:
            n = len(nums)
            sumation = [0]*(n+1)
            for i in range(1,n+1):
                sumation[i] = sumation[i-1]+nums[i-1]
            dp = [[_ for _ in range(n+10)] for _ in range(4)]
            for i in range(n-k+1,0):
                for j in range(1,4):
                    f[i][j] = max(f[i+1][j],f[i+k][j-1]+sumation[i+k-1]-sumation[i-1])
            ans = [0]*3
            i = 1
            j = 3
            idx = 0
            while j>0:
                if f[i+1][j]>f[i+k][j-1]+sumation[i+k-1]-sumation[i-1]:
                    i+=1
                else:
                    ans[idx+1]=i-1
                    i+=k
                    j-=1
            return ans
 ----------
 - 解析
 >