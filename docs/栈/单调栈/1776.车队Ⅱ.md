1776. 车队 II
----------
 - 题目
>
    在一条单车道上有 n 辆车，它们朝着同样的方向行驶。给你一个长度为 n 的数组 cars ，其中 cars[i] = [positioni, speedi] ，它表示：

    positioni 是第 i 辆车和道路起点之间的距离（单位：米）。题目保证 positioni < positioni+1 。
    speedi 是第 i 辆车的初始速度（单位：米/秒）。
    简单起见，所有车子可以视为在数轴上移动的点。当两辆车占据同一个位置时，我们称它们相遇了。一旦两辆车相遇，它们会合并成一个车队，这个车队里的车有着同样的位置和相同的速度，速度为这个车队里 最慢 一辆车的速度。
    
    请你返回一个数组 answer ，其中 answer[i] 是第 i 辆车与下一辆车相遇的时间（单位：秒），如果这辆车不会与下一辆车相遇，则 answer[i] 为 -1 。答案精度误差需在 10-5 以内。

 - 示例
 ----------
> input: 
> 
    cars = [[1,2],[2,1],[4,3],[7,2]]
> 
> 
> output: 
> 
    [1.00000,-1.00000,3.00000,-1.00000]
 ----------
 - 代码
 >
> 
    class Solution:
        def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:
            # 追上之后，会变成更慢的那辆
            # 按位置排序，只会追上前面的车
            # 初始位置更后面的点，如果被追上，则它自己的速度一定是更小的那个
    
            n = len(cars)
            res = [-1]*n
            stack = []
            stack.append(n-1)
    
            for i in range(n-1,-1,-1):
                # 考虑i追上前面一辆车之前，前面一辆车是否追上了更前面的车
                while stack:
                    # i车追不上栈顶的车，则栈顶的车不用考虑了
                    if cars[i][1]<=cars[stack[-1]][1]:
                        stack.pop()
                    # i车追上栈顶的车之前，栈顶的车就追上了更前面的车，所以栈顶的车不用考虑了
                    elif res[stack[-1]]>-1 and (cars[stack[-1]][0]-cars[i][0])/(cars[i][1]-cars[stack[-1]][1])>res[stack[-1]]:
                        stack.pop()
                    else:
                        break
                if stack:
                    # 找到i车能最快追上的车
                    res[i] = (cars[stack[-1]][0]-cars[i][0])/(cars[i][1]-cars[stack[-1]][1])
                    stack.append(i)
                else:
                    # 栈中没得车了，说明i车谁也追不上
                    res[i] = -1
                    stack.append(i)
            return res

  ----------
 - 解析
 >
> 显然，每辆车只可能追上**初始位置在它后面的车**；
> 
> 而追上之后又会合并，那就意味着，我们该从后往前来看；
> 
> 而这里面，显然最后一辆车的res一定是-1；
> 
> 因为它不可能追上任何车辆，而前面的车如果可以追上它，又会和它合并；
> 
  ----------
>
> 基于上述条件，我们可以知道，cars[i]一定只能追上 cars[i+1]---cars[n-1] 这些车；
> 
> 那么这里区分出情况；
> 
    1. cars[i]不能追上cars[i+1]---cars[n-1]中最慢的车；
    2. cars[i]可以追上cars[i+1]---cars[n-1]中的车；
> 
> 追不上的情况比较简单，如果cars[i]追不上后面的车，那么cars[0]---cars[i-1]也不可能追上cars[i+1]以及后面的车；
> 这是显然的，因为它们追上cars[i]就合并了；
> 
> 而追得上得情况比较复杂，因为需要考虑，cars[i]会和哪辆车合并；
> 
> 我们从后往前考虑，假设cars[i]追上cars[i+1]之前，cars[i+1]以及追上了cars[i+2]；
> 
> 那么我们也就不用考虑cars[i+1]了，而**只需要考虑cars[i]追上cars[i+1]的情况**；
> 
> 同理，对于cars[i+2]，我们考虑cars[i+2]是否先追上cars[i+3]即可；
> 
> 后面以此类推；
> 
> 因此可以得出结论，对追的上的情形，我们可以用栈去模拟，直到找到cars[i]最快能追上的车辆；
> 
> 