> 首先，动态规划问题的共有特征是 **问题的最优结构可以由问题的最优子结构得出**；
> 
> 因此，动态规划的填表过程其实是一步一步求取子问题的最优结构，然后由子问题的最优结构递推的求取总问题的最优解的过程；
>
> 而表的维度，取决于问题有多少种“状态”需要表述；
>
> 比如在背包问题中，
>
> 无限背包（如 零钱兑换问题） 只需要描述 硬币组合总值 这一种状态，所以只用一维；
>
> 而0-1背包问题（如 494.目标和）由于数组中每个数字智能使用一次， 则除了 目标值 以外，还需要描述数组里面 每个数值是否被使用；
>
----------
> 在编辑距离这个问题中，需要求解字符串A 与 字符串B 之间的最小编辑距离；
>
> 这个问题的最优解，可以由 字符串A的任意子串 与 字符串B的任意子串 之间的最小编辑距离递推得到；
>
> 因此，需要描述 字符串A的子串 和 字符串B的子串两种状态； 所以定义 dp[len(A)+1][len(B)+1]
>
> 不妨假设，A="h",B="r"，那么显然可以知道A和B的最小编辑距离为 1；
>
> 那么如果 A="ha",B="ra"，这时由于第二个字符是相同的，不用改变，所以只需要改变第一个字符就可以了，所以最小编辑距离为1；
>
> 在该情况下， A[:i]和B[:j]之间的最小编辑距离就等于 A[:i-1]和B[:j-1]之间的最小编辑距离；
>
> 即 dp[i][j] = dp[i-1][j-1]
>
> 反之，如果 A="ha",B="rb", 则需要考虑多种情况；
>
> 比如，我们得到"h"-->"rb"的编辑距离，在此基础上+1,即可得到"ha"-->"rb",因为"ha"删除一次"a"可以得到"h"；
>
> 同理，("ha"-->"r")-->("ha"-->"rb")对应的是添加， ("h"-->"r")--->("ha"-->"rb")对应的是修改；
>
> 综上，dp[i][j] = fun(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+1)；
>
> 显然我们要求的是最短的编辑距离，在这几种可能中取最小的，所以 fun() 为 min()；
>
> **由此可以看到，动态规划其实还是遍历了所有的可能，只是由于用dp数组记录了最优的子结构，所以可以直接借助最优子结构来递推**；
----------
> 综上可以得到，状态转移公式:
>
    dp[i][j] = dp[i-1][j-1]  if A[i]==B[j]
    dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1    if A[i]!=B[j]
> 假设二维数组dp左下角是(0,0)，右上角是(len(A),len(B))；
>
> 那么每个dp[i][j]，都取决于其 (左下角，左边一个，下面一个)；
>
> 因此我们必须从左往右，从下往上的填写此表，这样的填表过程，我们称之为自底向上；
>
> 反之，先知道最右上的结果，然后从右往左，从上往下填写的过程称为自顶向下（712.两个字符串的最小ASCII删除和）；