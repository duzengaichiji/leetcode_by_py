>
> 在所有的股票问题中，求解的问题都是最大化的利润；
>
> 最简单的思路就是求解出所有可行的交易，然后找到最优的交易组合；
>
> 对于n天，求出所有可能的交易，需要O(n²)，对于只需要一次交易的情况可以适用；
>
> 但是，对于限制k次交易的情况，需要求解最优的交易组合，这需要指数级的复杂度（搜索树）；
>
----------
> 不妨假设，此时已经求得， 前m天，交易k-1次 的最优交易组合，那么要求解 n天k次的最优组合，只需要求解 第m天到第n天的 最大利润的一次交易即可；
>
> 因此可以知道的是，n天k次 的最优组合，取决于其子问题 m天k-1次的最优组合；
>
> 所以，至少需要两个维度，dp[n][k]，其中dp[i][j]表示，第i天，进行了j次交易时，所获得的最大利润；
>
> 假设问题的总范围表示为(n,k)，那么可以看到，(n,k)的解由其子问题(m,k-1)推出，其中m<=n-1；
>
> 因此，这是一个自下而上填写的表；
>
> 又因为股票必须先买再卖，所以还需要一个维度来表示股票的持有状态，因此将定义dp[n][k][2]
>
> 其中,dp[i][j][0]表示，第i天，进行了j次交易并且未持有股票时，最大的利润；
>
> 其中,dp[i][j][1]表示，第i天，进行了j次交易并且持有股票时，最大的利润；
----------
> 对于这样定义的dp数组，显然有；
>
    dp[i][j][0] = max(dp[i-1][j][0],dp[i-1][j][1]+prices[i])
> 到第i天为止，进行了j次交易并且未持有股票时，最大的利润
>
> 取决于 之前已经进行了j次交易，并且未持有股票时获得的最大利润；
>
> 或 之前已经进行了j-1次交易且当前持有股票时 所获得的最大利润，加上 在第i天完成第j次交易所获得的利润；
>
    dp[i][j][1] = max(dp[i-1][j][1],dp[i-1][j-1][0]-prices[i])
> 到第i天为止，进行了j次交易并且持有股票时，最大的利润
>
> 取决于 之前已经进行了j次交易，并且仍持有股票时获得的最大利润；
>
> 或 之前已经进行了j-1次交易 所获得的最大利润，加上第i天完成第j次买入时的支出；
----------
> 另外，对于表的初始状态；
> 
> 对于任意天，dp[i][0][0] = 0，因为没有发生过交易，所以利润当然是0；
>
> 对于dp[i][0][1] = -infinity，因为没有发生过交易，是不可能持有股票的；
>
> 另外，对于第一天,dp[0][j][1] = -infinity，因为第一天是不可能发生过交易的；
----------
> 这里乍一看，公式与假设的情况似乎对不上，因为似乎要求(n,k)的解，要遍历m∈(k,n-1)所能定义的子问题(m,k-1)，加上对应第m天到第n天的最大利润的一次交易，取其最大者，才是最优解；
> 即
>
    fun(n,k) = max(fun(m,k-1)+ maxDeal(m,n)) { m∈(k,n-1) }
>
> 但实际上，状态转移公式中，**把交易当天的价格也看作利润**；
>
> 如果当天买入，则当天的利润是-prices[i]，如果卖出，则是+prices[i]；
>
> 因此，实际上在求取dp[i][j]的过程中，在第i天中获得的利润是**固定值**；
>
> 因此，无需考虑m的各种情况，因为在之前的填表过程中，已经求过了，到dp[i][j]的位置时，一定是最优的；
>
> 将利润定义为某两天的价格差，则真的需要考虑m∈(k,n-1)对应的各种情况，才能求得(n,k)的最优解；