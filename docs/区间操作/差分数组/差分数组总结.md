> 
> 当题目要求修改不断修改区间里面的数，最后要求区间的某个值（最大/最小，arr[i]。。。）时，
> 
> 最容易想到的办法，就是按照需要，逐个修改区间里的每个数字，但这样做需要O(n*n)的复杂度；
> 
> 引入差分数组 dep, 其中，dep[i] = arr[i]-arr[i-1]；
> 
> 这样，当需要变更某个区间[l,r]的值时，比如都加上k；
> 
> 则，只需要变更dep[l]以及dep[r+1]（显然，dep[l+1]到dep[r]是不会变的，因为它们也加上了k，所以其差值不变，
> 变的只有头尾值）；
> 
> 这样可以把区间修改的复杂度降低到O(n)；
> 
> 而用dep数组求取原来的数组，只需要累加即可；
> 
    for i in range(1,n):
        dep[i]+=dep[i-1]
> 
> 通常，区间修改类的题目都能用这个解决，万不得已才需要线段树；
> （线段树的优势只体现查询区间的时候）
> 
 ----------
> 关于差分数组的两种定义；
> 
> 一种是定义一个[0,n+1]的数组；
> 
    res = [0]*(n+1)
    for start,end in zip:
        # 左闭右开区间，区间内的都加，区间右侧的都减
        res[start]+=1
        res[end]-=1
>
> 这种通常用在，求取的结果是某个范围的完整数组，此时n的范围不会太大，直接定义差分数组不会超过空间复杂度上限的情况；
> 
> 另外一种定义是用sortedDict来保存这些变更点
> 
    from sortedcontainers import SortedDict
    cnt = SortedDict()
    for start,end in zip:
        cnt[start] = cnt.get(start,0)+1
        cnt[end] = cnt.get(end,0)-1
>
> sortedDict是一个一个实时保证key有序的字典，每次插入用o(logn)来保证key的有序
> 
> 这种一般用于不需要求取范围内所有值的情况，此时n可能被定义的很大；
> 
    for key,value in cnt.items():
        # 从上一个key到这个key之间的差分值都是0；
>
 ----------
> 一些题的差分数组的使用是结果导向的，这种情况，类似二分搜索去搜索答案，因此如果发现没有单调性提供二分法的使用条件，可以考虑用差分数组，比如798,1674；
> 
> 通过某些操作获得某种结果，然后求操作的最小数量；
> 
> 此时可以通过定义操作数数组res,数组的下表表示**结果的值**；
> 
> 这样就可以明确获取这些结果的时候需要的操作数，然后在差分数组上叠加，以获取结果；