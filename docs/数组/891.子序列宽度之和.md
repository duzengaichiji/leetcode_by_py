891. 子序列宽度之和
----------
 - 题目
> 
    一个序列的 宽度 定义为该序列中最大元素和最小元素的差值。

    给你一个整数数组 nums ，返回 nums 的所有非空 子序列 的 宽度之和 。由于答案可能非常大，请返回对 109 + 7 取余 后的结果。
    
    子序列 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，[3,6,2,7] 就是数组 [0,3,1,6,2,2,7] 的一个子序列。

 - 示例
 ----------
> input: nums = [2,1,3]
>
> output: 6
 ----------
 - 代码
 >
> 
    class Solution(object):
        def sumSubseqWidths(self, A):
            MOD = 10**9 + 7
            N = len(A)
            A.sort()
    
            pow2 = [1]
            for i in range(1, N):
                pow2.append(pow2[-1] * 2 % MOD)
    
            ans = 0
            for i, x in enumerate(A):
                ans = (ans + (pow2[i] - pow2[N-1-i]) * x) % MOD
            return ans


 ----------
 - 解析
 > 
> 假设我们枚举将要所有可能的子序列；
> 
> 我们假设所有子序列的最大/最小值为两个数组  maxs, mins；
> 
> 任意一个子序列对答案的贡献为 maxs[i]-mins[j]；
> 
> **反过来，对于数字num，如果它出现在maxs中（表示num是某些子序列的最大值），它对答案的贡献是 +num，反之，出现在mins中，则对答案的贡献是-num；**
> 
> 于是，我们需要求得 nums 中的所有num 对答案的贡献，也即**求得nums[i]作为最大/最小值的子序列的数量**；
> 
 ----------
>
> 将数组排序，因为不影响子序列；
> 
> 排序完，对于nums[i]，它前面的数字 nums[:i-1]都比它小，nums[i+1:]都比它大；
> 
> 我们选中nums[i]，再对它前面的nums[:i-1]选出 >1 个的组合；这样得到的子序列，是nums[i]作为最大值的子序列；
> 
> 同理可以得到nums[i]作为最小值的子序列；
> 
> nums[i]作为最大值的贡献为 2^i，作为最小值的贡献为 2^(length-i-1)；
> 
> 于是，就得到了答案中的代码
> 