377.组合总和IV
----------

标签（空格分隔）： leetcode

 - 题目

> 给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。

----------

- 示例

> nums = [1, 2, 3]
target = 4
> 
> 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3,
> 1)
> 
> 请注意，顺序不同的序列被视作不同的组合。
> 
> 因此输出为 7。

----------

 - 代码

>

    class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        if not nums:
            return 0
        dp = [0] * (target+1)
        dp[0] = 1
        # 目标循环在外层，备选数字循环在里层
        for i in range(1,target+1):
            for num in nums:
                if i >= num:
                    dp[i] += dp[i-num]
        return dp[target]


----------


 - 解析

> 用一组数字组合成目标数字，数组中的数可以无限使用，典型的完全背包问题；
> 与其他背包问题的不同之处在于，该题要求的是所有能形成目标值的**组合**（实际上是排列）数；
> 观察代码会发现，对比零钱兑换等问题，仅仅是两个循环之间谁嵌套谁的区别；
> **那么target循环在外和nums循环在外有什么区别？**


----------

    for num in nums:
        for i in range(num,target):
            dp[i] = func(dp[i],dp[i-num])

> 先来看nums循环在外的情形:
> 
> 我们不妨想象，dp里面每个位置存放的是，target=i 的解的合集，
> 最开始时，dp = [[-],[],[],[],...],经过第一次循环，也即使用nums中的第一个数字(假设是1）去填充大小为[1,target]的背包；
> 这时候dp = [[-],[(1,)],[(1,1)],[(1,1,1)],...];
> 可以看到，dp数组中每个位置代表用 "1" 去填充大小为 i 的背包的解；
> 下一轮循环，假设num=2；
> dp = [[-],[(1,)],[(1,1),(2,)],[(1,1,1),(2,1)]....]
> 再下一轮，num=3;
> dp = [[-],[(1,)],[(1,1),(2,)],[(1,1,1),(2,1),(3)]...]
> 
> dp中并没有记录(1,2)和(2,1)这样的区别，因为每次试图填充所有可能的背包时，都只用nums中的一个数字，即是说，nums中的数字是不会被重复尝试使用的；

----------

    for i in range(target):
        for num in nums:
            if i>=num:
                dp[i] = func(dp[i],dp[i-num])

> target循环在外：
> 
> 第一轮，target = 1;
> dp = [[-],[(1,)],[],[]....]
> 第二轮，target = 2;
> dp = [[-],[(1,)],[(1,1),(2)]...]
> 第三轮，target = 3;
> dp = [[-],[(1,)],[(1,1),(2)],[(1,2),(1,1,1),(2,1)]....]
> 
> 这里等于是每一轮用nums中所有的数字尝试去填充一个target=i的背包；
> 由于每一轮nums的数字都被使用，所有会区别组合中不同排列的情况；







